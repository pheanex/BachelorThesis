\chapter{Implementation}
  Our optimization is implemented as an addition to the AutoWDS basic, after it successfully created a stable network tree topology.(See \ref{autowdsbasic}).
  The additional steps are:
  
  \begin{enumerate}
   \item The accesspoints enable the background scan. This means the accesspoints cycle through all possible channels for a short period of time
    and look for other broadcastet wireless networks and store the recognized mac addresses and signal strength in a corresponding table.
    This scan is run on a regular interval for a few milliseconds.
   \item Accesspoints send scan results continuously to the central \ac{WLC}.
   \item When all the scan results are in, we read the scan-results table from the \ac{WLC} to our client station and parse the data to a networkX graph.
   \item At the client station we compute an optimized network topology. 
   \item Write back the data from the client station to the WLC to the configure-topology-table.
   \item The \ac{WLC} derives configuration files for the accesspoints and send them to the APs.
   \item APs receive the configuration files and reconfigure themselves to use the new network links.
   \item After a while the accesspoints rejoin the network through their new connections and again announce the network to other stations.
  \end{enumerate}
  
  Later eventually steps three to five will be also incorporated in the \ac{WLC}.
  
  \begin{figure}[h!]
    \centering
    \includegraphics[width=1\columnwidth]{figures/dataflow}
    \caption{General flow of information in AutoWDS extended}
    \label{fig:dataflow}
  \end{figure}

  \section{Language of choice}
    The language we used for the implementation is python2.7. Although we also could have implemented the extension in c/c++ since the basic version
    was already written in this language, python does have some key advantages we did not want to miss.
    
    \begin{description}
      \item [Rapid prototyping]
      Since our algorithms can easily work on a given set of data completely independent and the interfaces to get the data from are clearly defined and accessible,
      using a lightweight language like python had the benefit of not having to embed our new code into the existing environment. Although it still can be implemented 
      in the native language C/C++ for our scenario, this will take some more time and effort, which was not the focus of this work.
      \item[Existing libraries]
      like NetworkX in python made it particulary easy for us to map real world scenarios to graph abstractions as we did not have to create those structures ourselves.
      Although there are some libraries that provide graph abstractions in C/C++ we could not have as easily employed them due to their copyright restrictions and 
      the closed source virtue of our target system.
      \item[Faster Debugging]
      Especially the initial phase of the project was errorprone and needed a lot of debugging. Not having to recompile after every fix turned out to be
      a great saving of time. Not to mention the live debugging capabilities of python, which was really helpful.
      \item[Existing APIs]
      Fortunately also the code for interaction with the interfaces (SNMP/SSH/Telnet) of the WLC was written in Python, so we could easily 
      integrate it into ours and had no problem gathering the 'seen'-data. Unfortunately for you those libraries are closed source to the public.
      \item[Maintainability]
      As python has the reputation of being an easy to learn language, this was another benefit and played absolutely in our favor with the goal of
      keeping the code simple, lightweight and reuseable by someone else.
    \end{description}
    
    \newpage
    
  \section{Dependencies}
    As already mentioned we used NetworkX\cite{hagberg-2008-exploring} to model our graphs and work with its elements.
    NetworkX's rich features like ``has\_path'' made things especially easy in computing the survival paths.
    Another library we used is python collections. \cite{python_collections}
    This library implements specialized container datatypes additionally to those shipped with standard python.
    It's `Counter` structure is used to create the channel-lists and retrieve the most or least used elements.
    We extended this library for our convencience since it did only provide the functionality for getting the most common element from its list and not the least common,
    which we needed. \footnote{It is worth mentioning that the request for including this method was already issued at 01/2013 http://bugs.python.org/issue16994}
    The only closed source library we used is the herein before mentioned library to query the WLC for the data of the APs. Nevertheless gathering the data can also
    easily be separated and outsourced to different interfaces.
  
  \section{Structure of the Code}
    We split the code into two modules. The one handling connections, sending/receiving and transforming data to and from networkX graphs and the other one 
    deals with only with graphs and therefore the theoretical problem.
    
    \subsection{Interfacing Outer World and Managing Data}      
     \begin{table}[h!]
	\begin{tabular}{clll}
	  Device Mac Address & Module Mac Address & Seen Module Mac Address & \ac{SNR}\\ \hline
	  ece55574a4d5 & ece555ffd61e & ece555ffd5bf & 56 \\
	  ece55574a4d5 & ece555ffd6cc & ece555ffd5b9 & 48 \\
	  ece55574a4a5 & ece555ffd667 & ece555ffd5d6 & 33 \\
	  ... & ... & ... & ...
	\end{tabular}
	\caption{Mesh network topology representation in table format on a LANCOM WLC. Device mac address is the LAN mac address, the module mac address is
	  the address of the module which is equipped on the device and which receives the Beacons with the ESSIDs of other modules, which in turn translates
	  the ESSID to the mac address of the opposing module. The \ac{SNR} describes thereon the quality of the link between those two modules.}
	\label{tab:wlc}
      \end{table}
      
      The name of the module is \textit{wlc\_com}. This module's responsibilites include the following:
      \begin{description}
	\item[Receiving the necessary data:]
	  For this purpose we use the closed source python library 'testcore', which creates a SSH/Telnet connection to the WLC and parses its tabledata.
	  The information we receive is of the following form:
	
	\item [Transform the data to a networkX graph:]
	  The tabledata from above can then be molded into a directed, weighted networkX graph. Where we create a node for each mac address and module mac address and attach a boolean
	  attribute to it to tell them apart. 
	  In parallel we add two types of edges:

	  \begin{itemize}
	    \item Fake edges between module-nodes and device-nodes with an attribute "SNR" which contains the maximum possible value for this attribute.
	    
	    \item Real edges for each line in the table above, where the two nodes are the module mac address pairs. 
	      Note that one row in the table represents just a directed edge from one module to the other. We only respect two-sided connections,
	      since one-sided edges are mostly of poor quality and would further complicate finding a solution.
	      As we have two SNR-values for a single undirected edge when merging two directed edges, we are at liberty to chose.
	      Currently we are using the average of both values, but implemented an option to use the larger or the smaller value if favoured.
	      Especially the lower SNR value might better represent a connection for more pessimistic scenarios.
	  \end{itemize}

	\item[Conducting a validity check on the result:\newline]
	  Before generating the configuration and sending the result to the WLC we have the option perform some sanity checks on the outcome.
	  Among others we test for the following:
	  \begin{itemize}
	    \item Is each device connected to the network, or are there disconnected components?
	    \item Do modules which are supposed to establish a connection use the same channel and Band?
	    \item Are only channels used which have been specified as input?
	    \item Are all devices only connected to their modules over module-device edges?
	  \end{itemize}
	  
	\item [Send results back to the WLC:]
	  If we were able to compute a solution and all checks passed we again establish a connection to the WLC and write back a network topology and channel assignment
	  configuration. This configuration will then be enforced on the accesspoints by the managing WLC.
	  This is done by configuring each module to use only the assigned channel and set entries in the network topology table. Depending on other parameters the
	  accesspoints will then after a while receive their specific configurations and act on those.
      \end{description}
      
      \clearpage
      \newpage
      
    \subsection{Solving the Theoretical Problem}
      The module for this job is named \textit{tcca} and handles finding the solution based on graphs.
      With a given undirected networkX graph we can compute a solution in three phases analogous to the algorithmic design.
      First we create a minimal spanning tree, followed by computing the survival paths and finally assigning channels to the resulting network topology.

      \subsubsection{Creating the Minimal Spanning Tree}
	In the first phase take the networkX graph as input we either randomly created or receive from \textit{wlc\_com}-module and call the "calculate\_st"-function.
	This function starts by randomly selecting a start-node and putting this node into the visited-set. At the same time it also creates a counter-list
	called edge-list with all the edges to neighbors of the initial nodes the calculated edge score as their corresponding values.
	
	After this initialization it enters the main loop by removing all the elements in the edge-list, which do not lead to new, up to now unseen nodes. 
	We call those nodes unproductive.
	To escape the loop at some point, it is then checked if the edge-list is now empty to leave the loop, or if there still are some edges to new nodes.
	The most of the time the loop spends with with the following:
	
	\begin{itemize}
	 \item Select the edge with the higest score from the edge-list
	 
	 \item Expand the edge. This includes adding it to the MST, adding the appropriate nodes to the visited-set and adding all productive edges with their edge-scores to the edge-list.
	 
	 \item Throw out the used edges to speed up updating the edge-scores.
	\end{itemize}
	
	In order to calculate the score of an edge this main function makes use of another function "calculate\_score\_for\_edge".
	Here basically all the necessary values for the key formula are gathered and the edge-score is then calculated.
	
	After successful execution of the loop a minimal spanning tree in form of a networkX graph is returned to the caller.
	
      \subsubsection{Calculating the Survival paths}
	With the MST graph we are now able to add redundand paths. As you might have already guessed the function's name for this job is "calculate\_survival\_links".
	To simulate each edge failing, this function iterates over all the edges in the MST and removes these edges from the MST.
	This sub-MST is then used to check if it already contains an alternative path from and to the nodes of the failing edge.
	Luckily networkX already provides such a test with "has\_path". Only if this test fails we continue by creating our two groups A and B for each side of the split graph.
	The most costly part is then iterating again over all edges in the underlying graph and checking if this edge would reunite the halves of the graph and determining 
	their scores. Finally we pick the best edge from the counter-list and add it together with its failing edge back to the MST.
	
      \subsubsection{Coloring the Edges}
	For the last phase of assigning channels to the edges/modules we use the "calculate\_ca"-function. This one uses either the MST graph or the survival-graph as input additionally
	to the necessary underlying network graph and a list of allowed-channels.
	To start we initialize the overall-channel-counter with zeros which tracks overall channel usage in case there are ties.
	We iterate again over all edges in the graph and skip over all edges, that are not module-module edges or are already colored. 
	For each uncolored edge we then determine the channel-group by running a BFS-search over all connected modules.
	As required by the design we now need to estimate the local interferences.
	This is done by the function "count\_local\_interference" which returns two counters-lists: internal- and external- interference.
	Those contain channels with a number of interference clashes as their values, which means how often the use of a certain channel would interfere with other modules 
	in the area of the channel-group. Naturally we continue by chosing the channel which has the lowest value in this counter, as this channel or channels would interfere the least
	with its environment. The phase finishes by entering the tie-breaker section by extending the chosing process to the overall-channel-counter and at last randomness if
	the outcome is not of singular nature.
	At last the designated channel is assigned to the elements of the channel group.
	Just as the others, this function returns a networkX graph, but now with channels assigned to the edges and modules of the allowed-channel-set.	

  \section{Example}
    To give you an impression on how to work with the code, we illustrate the process of finding a solution by taking a look at an example.
    See the code snippet in \ref{tab:python-example}.
    Therefor we create a grid network with random edge weights (Line 5 - 41).

    To get the initial MST from this graph we call the "calculate\_st" function on it (Line 43 / left figure in \ref{fig:3x3second}).
    
    Adding the redundant paths works just as easily by using the "calculate\_survival\_links" function (Line 45/right figure in \ref{fig:3x3second}).
    
    Finally we want to assign channels / colors to the edges by utilizing "calculate\_ca" on the two graphs (Lines 47/49 and \ref{fig:3x3third}).
    
    \newpage
    
    \begin{table}[h!]
    \lstset{language=Python}
    \begin{lstlisting}
  import networkx as nx
  import random
  import tcca

  graph = nx.Graph()

  for i in range(9):
      i = str(i)
      graph.add_node(i, isModule=False)
      for j in range(2):
	  j = str(j)
	  module_name = i + "." + j
	  graph.add_node(module_name, isModule=True)
	  graph.add_edge(i, module_name)
	  graph.edge[i][module_name]["snr"] = max_weight = 1000

  seen_links = {0: [0, 1, 3, 4], 
		1: [0, 1, 2, 3, 4, 5], 
		2: [1, 2, 4, 5], 
		3: [0, 1, 3, 4, 6, 7], 
		4: [0, 1, 2, 3, 4, 5, 6, 7, 8], 
		5: [1, 2, 4, 5, 7, 8], 
		6: [3, 4, 6, 7], 
		7: [3, 4, 5, 6, 7, 8], 
		8: [4, 5, 7, 8]}

  for node_a in seen_links:
      for node_b in seen_links[node_a]:
	  for i in range(2):
	      i = str(i)
	      for j in range(2):
		  j = str(j)
		  node_a = str(node_a)
		  node_b = str(node_b)
		  moda = node_a + "." + i
		  modb = node_b + "." + j

		  if moda == modb:
		      continue

		  graph.add_edge(moda, modb, snr=random.randint(30, 96))

  st_graph = tcca.calculate_st(graph)

  survival_graph = tcca.calculate_survival_links(st_graph, graph)

  ca_mst_graph = tcca.calculate_ca(st_graph, graph, [1, 6, 11])

  ca_survival_graph = tcca.calculate_ca(survival_graph, graph, [1, 6, 11])
    \end{lstlisting}
    \caption{The python code for generating the example network graph and solutions. Note the tcca import, 
      which is our library for topology creation and channel assignment.}
    \label{tab:python-example}
  \end{table}
  
  \newpage
  
    \begin{figure}[h!]
      \centering
      \includegraphics[width=0.39\columnwidth]{figures/3x3ap_range}
      \includegraphics[width=0.6\columnwidth]{figures/3x3seen}
      \caption{Grid layout with two radio modules per \ac{AP} (left). Resulting network topology (right). Thicker edges indicate higher link-SNR.}
      \label{fig:3x3initial}
    \end{figure}
    
    \begin{figure}[h!]
      \centering
      \includegraphics[width=0.49\columnwidth]{figures/3x3mst}
      \includegraphics[width=0.49\columnwidth]{figures/3x3robust}
      \caption{Spanning tree on the graph(left) and spanning tree with survival paths(right)}
      \label{fig:3x3second}
    \end{figure}
    
    \begin{figure}[h!]
      \centering
      \includegraphics[width=0.49\columnwidth]{figures/3x3_ca_mst}
      \includegraphics[width=0.49\columnwidth]{figures/3x3_ca_robust}
      \caption{Spanning tree with channels assigned(left) and spanning tree with survival paths with channels assigned(right)}
      \label{fig:3x3third}
    \end{figure}
    
    \newpage
  
  \section{Problems and Aids}
    \begin{description}
    \item [AutoWDS Status Tool:]
	To make things easier for debugging and also to actually see what is going on during the execution of the algorithms,
	we and most of all my Christoph Wollgarten created a tool called AutoWDS, which is based on \cite{d3js}. 
	Furthermore attached with a tool to extract data from the WLC, it is able to display current statuses and established links of a deployed network.
	
	It works by reading a graph represented as a \ac{JSON}-file and displays it interactively in html with javascript.
	As it is basically a force directed graph, the nodes position themselves according to their SNR-edge-values. 
	Additionally you can drag and position single nodes freely anywhere on the map for better singularization of entities.
	In the tcca module we also included an export function called "write\_json(graph, filename)" which creates a json file to be read by the autowdsstatus tool.
	This tool has also been used to create most of the images in this thesis.
	
    \item [Representation of Tables in LANCOM Devices:]
	While writing the code which deals with the WLC and receives the data, we initially had some difficulties extracting the data out of the tables represented in the WLC since
	they reside there in a somewhat obscure format and are spread over different tables. So that we effectively had to gather the data and join them so that we receive a
	nice tables like \ref{tab:wlc} we can work with. Nevertheless we were able to cope with it, although the code for it is somewhat longer and cumbersome.
	
      \item [Python Logging Module:]
	Another great helper turned out to be the utilization of pythons logger module. We excessively made use of its Error/Warning/Info/Debug statements which made debugging
	a lot easier without being an obstacle if we did not need the output as we could just switch to a different level of logging and enjoy the silence.
    \end{description}

    \begin{figure}[h]
      \centering
      \includegraphics[width=0.85\columnwidth]{figures/autowdsstatus}
      \caption{AutoWDS status webinterface showing a network topology}
      \label{fig:autowdsstatus}
    \end{figure}
  
\clearpage

  
